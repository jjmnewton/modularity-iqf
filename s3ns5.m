P<x,y>:=PolynomialRing(Rationals(),2);
AP:=AffineSpace(P);


/* X(s3) is a projective line with j-invariant 3^3*(x+1)^3*(x-3)^3/x^3 */
/* j-invariant on X(ns5) is 5^3*y*(2*y+1)^3*(2*y^2+7*y+8)^3/(y^2+y-1)^5 */

fxy := 3^3*(x+1)^3*(x-3)^3*(y^2+y-1)^5 - x^3*5^3*y*(2*y+1)^3*(2*y^2+7*y+8)^3;


/* define singular model for X(s3,ns5) */ 
C := Curve(AP,fxy);
assert(Genus(C) eq 3);
j3 := FunctionField(C)!(3^3*(x+1)^3*(x-3)^3/x^3);

/* define two Q(sqrt(-55)) points of C */
Q55P1 := Place([FunctionField(C)!((2*y^2 - 3*y + 8)/2),FunctionField(C)!((27*y^4 + 54*y^3 - 27*y^2 - 54*y + 27)*x + 1125*y/8)]);
Q55P2 := Place([FunctionField(C)!((2*y^2 - 3*y + 8)/2),FunctionField(C)!((27*y^4 + 54*y^3 - 27*y^2 - 54*y + 27)*x - 30375*y/8)]);

/* check j-invariants are -32768 as claimed */
assert(j3(RepresentativePoint(Q55P1)) eq -32768);
assert(j3(RepresentativePoint(Q55P2)) eq -32768);

/* compute image of canonical map for C*/
CanMap := CanonicalMap(C);
D := CanonicalImage(C,CanMap);

/* check D still has genus 3, so curve was not hyperelliptic */
assert(Genus(D) eq 3);


/* check D is isomorphic to curve with simpler defining equation */
PD<X,Y,Z>:=AmbientSpace(D);
eqn := -X^4 + 2*X^3*Y + X^2*Y^2 + 8*X^3*Z + 2*X^2*Y*Z - 2*X*Y^2*Z - Y^3*Z - 3*X^2*Z^2 -  3*X*Y*Z^2 + 3*Y^2*Z^2 + 2*X*Z^3 - 3*Y*Z^3 + Z^4;

Xs3ns5 := Curve(PD,eqn);
tf, Iso:=IsIsomorphic(D,Xs3ns5);
assert(tf);

AttachSpec("./hyperelliptic-main/magma/spec");
AttachSpec("./quartic-main/magma/spec");

/* compute automorphism group to find the bielliptic involution */
AutomorphismsOfPlaneQuartic(Xs3ns5);

/* here is the involution */
inv := iso<Xs3ns5->Xs3ns5|[3*X+Y+2*Z,8*X+Y-8*Z,4*X-2*Y+Z],[3*X+Y+2*Z,8*X+Y-8*Z,4*X-2*Y+Z]>;


/* record map from C to Xs3ns5 */
MapDown := CanMap*Iso;

/* Check that the places Q55P1, Q55P2 correspond to the points P_1, P_2 in Proposition 7.4.1 */
K55<a> := QuadraticField(-55);
K:= Ring(Parent(RepresentativePoint(Q55P1))); /* field of definition for Q55P1 */
assert(IsIsomorphic(K,K55));
assert([K55!Coord: Coord in Coordinates(MapDown(RepresentativePoint(Q55P1)))] eq [ 1/28*(a + 1), 1/56*(-a + 27), 1 ]);

K:= Ring(Parent(RepresentativePoint(Q55P2))); /* field of definition for Q55P2 */
assert(IsIsomorphic(K,K55));
assert([K55!Coord: Coord in Coordinates(MapDown(RepresentativePoint(Q55P2)))] eq [ 1/4*(-a + 3), 1/4*(3*a + 3), 1 ]);

/* Compute order of J(F_p) for J = Jac(Xs3,ns5), p small prime of good reduction */
primelist := [7,11,13];
Jacorderlist := [];
for p in primelist do
Fp:=GF(p);
Xpp:=ChangeRing(Xs3ns5,Fp);
assert(not IsSingular(Xpp));
CGp,phi,psi:=ClassGroup(Xpp);
ZAbGroup:=FreeAbelianGroup(1);
degr:=hom<CGp->ZAbGroup | [ Degree(phi(a))*ZAbGroup.1 : a in OrderedGenerators(CGp)]>;
JFp:=Kernel(degr); 
Append(~Jacorderlist,#JFp);
end for;

assert(GCD(Jacorderlist) eq 20); /* GCD of Jacobian orders is equal to 20*/

/* Describing generators of torsion subgroup in J(Q) */
old10tors := (Divisor(Xs3ns5![0,1,1])-Divisor(Xs3ns5![-3,7,1]));

FF<u,v> := FunctionField(Xs3ns5);

Pl1:= Place([u^2 - 5*u + 1,v + 2*u - 1]);
Pl2:= Place([u^2 + u - 1,v + 3*u - 3]);

new2tors := 5*Divisor(Xs3ns5![-1/2,-1/2,1])+5*Pl2-10*Pl1+5*Divisor(Xs3ns5![0,1,0]);

/* Check order of new10tors is 10 and order of new2tors is 2 */
assert(not IsPrincipal(5*old10tors) and not IsPrincipal(2*old10tors) and IsPrincipal(10*old10tors));
assert(not IsPrincipal(new2tors) and IsPrincipal(2*new2tors));

/* Check that new2tors is not in subgroup generated by old10tors */
assert(not IsPrincipal(new2tors - 5*old10tors));

load "./quadraticpoints-master/ozmansiksek.m";
load "./quadraticpoints-master/quadptssieve.m";

/* Search for some rational degree two divisors */
deg2,pls1,pls2,plsbig:=searchDiv2(Xs3ns5,10,true);

/* Here is the quotient map to Xns3ns5 */
Xns3ns5, quotMap := CurveQuotient(AutomorphismGroup(Xs3ns5,[inv]));

//We split deg2 into divisors pulled back from Xns3ns5(Q) and the rest
deg2pb:=[1*pl : pl in pls2 | quotMap(RepresentativePoint(pl)) in Xns3ns5(Rationals())] cat 
[1*pl1 + 1*pl2 : pl1 in pls1, pl2 in pls1 | inv(RepresentativePoint(pl1)) eq RepresentativePoint(pl2)];
deg2npb:=[DD : DD in deg2 | not DD in deg2pb];
assert Seqset(deg2) eq Seqset(deg2pb cat deg2npb); 

//We convert to a minimal model for the elliptic curve Xns3ns5 and pullback a generator of the Mordell-Weil group to a degree 0 divisor on Xs3ns5
E,emap := EllipticCurve(Xns3ns5,quotMap(Xs3ns5![0,1,0]));
MapDtoC := quotMap*emap;
Emin, eminmap := MinimalModel(E);
MapDtoEmin := MapDtoC*eminmap;
defMapmin := DefiningPolynomials(MapDtoEmin);
MapDtoEmincomp := map<Xs3ns5->Emin|defMapmin>;
MWE,phi,tf1,tf2:=MordellWeilGroup(Emin);
genusC := Genus(Emin);

B := Pullback(MapDtoEmincomp,Place(phi(MWE.1)));
bp := Pullback(MapDtoEmincomp,Place(Zero(Emin))); 

B1 := B - bp; // B1 is the pull back to Jac(Xs3ns5) of a generator "D" as in Prop. 7.4.4

G:=AbelianGroup([0,2,2]);
divs := [5*B1,new2tors,5*old10tors]; // These divisors generate an Abelian group which contains 10 Jac_X(Q).
I := 10; 
genusC:=Genus(Emin);

auts:=[Transpose(Matrix(inv))]; // definition of the involution in format needed for Box's function

// Apply Box's Mordell--Weil sieve for the primes [11,43]
MWSieve(deg2,[11,43],Xs3ns5,G,divs,auts,genusC,deg2pb,deg2npb,I,bp);

// Output true means we succeeded and all non-pulled back degree two divisors already appear in deg2npb
//We check that the only exceptional imaginary quadratic points are those defined over Q(sqrt(-55)) which have already been identified
knowntwo:=[Place(MapDown(RepresentativePoint(Q55P1))),Place(MapDown(RepresentativePoint(Q55P2)))];
newtwo:= [pl : pl in pls2 | not quotMap(RepresentativePoint(pl)) in Xns3ns5(Rationals()) and Discriminant(Ring(Parent(RepresentativePoint(pl)))) lt 0];
assert(knowntwo[1] eq newtwo[1] or knowntwo[1] eq newtwo[2]);
assert(knowntwo[2] eq newtwo[1] or knowntwo[2] eq newtwo[2]);

